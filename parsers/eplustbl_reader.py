"""
Utility to read EnergyPlus eplustbl.csv output files for specific data.

This module provides functions to read key data from the eplustbl.csv output file 
generated by EnergyPlus simulations. Currently it extracts:

1. Glazing area data from "Area of Multiplied Openings [m2]" column
2. Glazing U-value data from "Glass U-Factor [W/m2-K]" column

These values are used in area reports to provide more accurate glazing information
based on the simulation results rather than the IDF input file values.
"""
import csv
import os
from typing import Dict, Any, Optional
from utils.logging_config import get_logger

logger = get_logger(__name__)

from .utils import safe_float

def _find_csv_path(csv_path: Optional[str]) -> Optional[str]:
    # Check provided path first
    if csv_path and os.path.exists(csv_path):
        return csv_path
    
    # Try multiple possible locations
    search_paths = [
        os.path.join("simulation_output", "eplustbl.csv"),  # Default relative path
        os.path.join(os.getcwd(), "simulation_output", "eplustbl.csv"),  # Absolute from current directory
        "eplustbl.csv",  # Current directory
        os.path.join("tests", "eplustbl-test.csv")  # Development fallback
    ]
    
    for path in search_paths:
        if os.path.exists(path):
            logger.info(f"Found eplustbl.csv at: {path}")
            return path
    
    logger.warning(f"No eplustbl.csv found. Searched paths: {search_paths}")
    return None


def _parse_exterior_fenestration_table(reader) -> Dict[str, Dict[str, Any]]:
    header_map = {
        "construction": 1,
        "area of multiplied openings [m2]": 6,
        "glass u-factor [w/m2-k]": 7,
        "glass shgc": 8,
        "glass visible transmittance": 9,
        "cardinal direction": 16
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
        if not in_target_table and row[0].strip().lower() == "exterior fenestration":
            in_target_table = True
            headers_found = False
            col_indices = {}
            continue
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                if "construction" in current_headers_norm and "glass u-factor [w/m2-k]" in current_headers_norm:
                    for key_map, expected_idx in header_map.items():
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.error(f"Header '{key_map}' not found in {current_headers_norm}. Expected based on map: {header_map}")
                            if key_map not in current_headers_norm:
                                logger.warning(f"Critical header '{key_map}' not found in CSV row: {row}. CSV structure might be unexpected.")

                    missing_keys = [k for k in header_map if k not in col_indices]
                    if missing_keys:
                        logger.error(f"Missing critical column indices for: {missing_keys} after parsing headers {current_headers_norm}")

                    headers_found = True
                continue
            else:
                suffixes_to_check = ["_WALL", "_ROOF", "_FLOOR", "_WIN", "_DOOR"]

                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    break

                max_col_idx_needed = 0
                if col_indices:
                    max_col_idx_needed = max(
                        col_indices.get("construction", 0),
                        col_indices.get("area of multiplied openings [m2]", 0),
                        col_indices.get("glass u-factor [w/m2-k]", 0)
                    )

                if len(row) > 1 and row[1].strip() and len(row) > max_col_idx_needed:
                    fenestration_surface_name = row[1].strip()

                    required_cols_for_data = ["construction", "area of multiplied openings [m2]", "glass u-factor [w/m2-k]"]
                    if not all(col_name in col_indices for col_name in required_cols_for_data):
                        logger.warning(f"Skipping row due to missing critical column indices for data extraction: {row}. Found indices: {col_indices}")
                        continue

                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["area of multiplied openings [m2]"]])
                    u_value = safe_float(row[col_indices["glass u-factor [w/m2-k]"]])

                    derived_zone_name = fenestration_surface_name
                    found_suffix = False
                    for suffix in suffixes_to_check:
                        if suffix in fenestration_surface_name:
                            derived_zone_name = fenestration_surface_name.split(suffix)[0]
                            found_suffix = True
                            break
                    if not found_suffix and '_' in fenestration_surface_name:
                        parts = fenestration_surface_name.split('_', 1)
                        if ':' in parts[0]:
                            derived_zone_name = parts[0]

                    if fenestration_surface_name and construction_name:
                        result[fenestration_surface_name.upper()] = {
                            'Construction': construction_name,
                            'Area': area,
                            'U-Value': u_value,
                            'DerivedZone': derived_zone_name,
                            'CardinalDirection': row[col_indices["cardinal direction"]].strip() if "cardinal direction" in col_indices else "Unknown"
                        }
    return result

def _parse_opaque_construction_table(reader, table_name: str) -> Dict[str, Dict[str, Any]]:
    """Parse opaque construction tables (Opaque Exterior or Opaque Interior)"""
    header_map = {
        "construction": 2,  # Construction is in column 2, not 1
        "gross area [m2]": 6,  # Gross Area is in column 6 based on CSV structure
        "u-factor with film [w/m2-k]": 4,
        "u-factor no film [w/m2-k]": 5
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
            
        # Look for the target table (e.g., "Opaque Exterior" or "Opaque Interior")
        if not in_target_table and row[0].strip().lower() == table_name.lower():
            in_target_table = True
            headers_found = False
            col_indices = {}
            continue
            
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                if "construction" in current_headers_norm and "gross area [m2]" in current_headers_norm:
                    for key_map in header_map:
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.warning(f"Header '{key_map}' not found in {table_name} table headers")
                    headers_found = True
                continue
            else:
                # Check for end of table
                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    break
                    
                # Extract construction data
                if len(row) > 2 and row[1].strip() and "construction" in col_indices and "gross area [m2]" in col_indices:
                    surface_name = row[1].strip()  # Surface name is always in column 1
                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["gross area [m2]"]])
                    u_factor = safe_float(row[col_indices.get("u-factor with film [w/m2-k]", col_indices.get("u-factor no film [w/m2-k]", 0))])
                    
                    # Store both surface name and construction name as keys
                    surface_data = {
                        'Construction': construction_name,
                        'Area': area,
                        'U-Factor': u_factor,
                        'Type': table_name,
                        'SurfaceName': surface_name
                    }
                    
                    if surface_name:
                        result[surface_name.upper()] = surface_data
                    if construction_name:
                        result[construction_name.upper()] = surface_data
    return result

def read_construction_areas_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read both glazing and opaque construction area data from eplustbl.csv.
    Returns a dictionary mapping surface/construction names to their areas and properties.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        logger.warning("eplustbl.csv not found - construction areas will use calculated values")
        return result
        
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            # Read glazing data from Exterior Fenestration
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            glazing_data = _parse_exterior_fenestration_table(reader)
            result.update(glazing_data)
            
            # Read opaque exterior construction data
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            opaque_exterior = _parse_opaque_construction_table(reader, "Opaque Exterior")
            result.update(opaque_exterior)
            
            # Read opaque interior construction data
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            opaque_interior = _parse_opaque_construction_table(reader, "Opaque Interior")
            result.update(opaque_interior)
            
        logger.info(f"Read construction areas for {len(result)} items from eplustbl.csv")
        return result
        
    except Exception as e:
        logger.warning(f"Error reading construction areas from CSV: {e}")
        return result


def _parse_zone_summary_table(reader) -> Dict[str, Dict[str, Any]]:
    """
    Parse the Zone Summary table from EnergyPlus CSV output.
    
    Returns:
        Dict mapping zone names to {'area': float, 'multiplier': int}
    """
    result = {}
    in_zone_summary = False
    headers = []
    row_count = 0
    
    for row in reader:
        row_count += 1
        if not row:
            continue
            
        # Debug: Log first 10 rows to see CSV structure
        if row_count <= 10:
            logger.debug(f"CSV row {row_count}: {row}")
            
        # Look for Zone Summary table header
        if len(row) > 0 and 'Zone Summary' in str(row[0]):
            logger.info(f"CSV PARSE DEBUG: Found Zone Summary table at row {row_count}")
            in_zone_summary = True
            continue
        
        if in_zone_summary:
            # Check if this is the header row (contains "Area [m2]" and "Multipliers")
            if not headers and row and any('Area [m2]' in str(cell) for cell in row):
                headers = [str(cell).strip().lower() for cell in row]
                logger.info(f"CSV PARSE DEBUG: Found Zone Summary headers: {headers}")
                continue
            
            # Check if we've reached the end of the table (empty row or new section)
            # Data rows start with empty column, so check if both first two columns are empty
            if headers and row and len(row) >= 2 and (not row[0].strip() and not row[1].strip()):
                logger.info(f"CSV PARSE DEBUG: End of Zone Summary table at row {row_count}")
                break
                
            # Process data rows (data rows may have fewer columns than headers)
            if headers and row and len(row) >= 6:
                logger.info(f"CSV PARSE DEBUG: Processing data row: {row[:5]}...")  # Show first 5 columns
                try:
                    # Zone name is always in column 1 (index 1)
                    zone_name_idx = 1
                    area_idx = None
                    multiplier_idx = None
                    conditioned_idx = None
                    part_of_total_idx = None
                    
                    # Find area, multiplier, and HVAC flags columns
                    for i, header in enumerate(headers):
                        header_lower = str(header).strip().lower()
                        if header_lower == 'area [m2]':
                            area_idx = i
                            logger.info(f"CSV PARSE DEBUG: Found Area column at index {i}")
                        elif 'multiplier' in header_lower:
                            multiplier_idx = i  
                            logger.info(f"CSV PARSE DEBUG: Found Multiplier column at index {i}")
                        elif 'conditioned' in header_lower and '(y/n)' in header_lower:
                            conditioned_idx = i
                            logger.info(f"CSV PARSE DEBUG: Found Conditioned column at index {i}")
                        elif 'part of total' in header_lower and '(y/n)' in header_lower:
                            part_of_total_idx = i
                            logger.info(f"CSV PARSE DEBUG: Found Part of Total column at index {i}")
                    
                    logger.info(f"CSV PARSE DEBUG: Column indices found - area: {area_idx}, multiplier: {multiplier_idx}, conditioned: {conditioned_idx}, part_of_total: {part_of_total_idx}")
                    
                    if zone_name_idx is not None and area_idx is not None:
                        zone_name = str(row[zone_name_idx]).strip()
                        area = safe_float(row[area_idx], 0.0)
                        multiplier = int(safe_float(row[multiplier_idx], 1.0)) if multiplier_idx is not None else 1
                        
                        # Extract HVAC and energy report flags
                        has_hvac = False
                        include_in_energy = False
                        
                        if conditioned_idx is not None and conditioned_idx < len(row):
                            conditioned_val = str(row[conditioned_idx]).strip().upper()
                            has_hvac = conditioned_val == 'YES' or conditioned_val == 'Y'
                            
                        if part_of_total_idx is not None and part_of_total_idx < len(row):
                            total_val = str(row[part_of_total_idx]).strip().upper()
                            include_in_energy = total_val == 'YES' or total_val == 'Y'
                        
                        if zone_name and area > 0:
                            result[zone_name] = {
                                'area': area,
                                'multiplier': multiplier,
                                'has_hvac': has_hvac,
                                'include_in_energy': include_in_energy
                            }
                            logger.info(f"CSV PARSE DEBUG: Parsed zone {zone_name}: area={area}, multiplier={multiplier}, hvac={has_hvac}, energy={include_in_energy}")
                        
                except (ValueError, IndexError) as e:
                    logger.warning(f"Error parsing zone data: {e}")
                    continue
    
    if not in_zone_summary:
        logger.info("CSV PARSE DEBUG: Zone Summary table not found in CSV")
    elif not headers:
        logger.info("CSV PARSE DEBUG: Zone Summary headers not found")
    else:
        logger.info(f"CSV PARSE DEBUG: Processed Zone Summary table, found {len(result)} zones")
    
    return result

def read_zone_areas_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read zone area data from the eplustbl.csv file Zone Summary table.
    Returns a dictionary mapping zone names to their area data.
    """
    result = {}
    logger.info(f"CSV PARSE DEBUG: read_zone_areas_from_csv called with path: {csv_path}")
    resolved_path = _find_csv_path(csv_path)
    logger.info(f"CSV PARSE DEBUG: _find_csv_path resolved to: {resolved_path}")
    if not resolved_path:
        logger.warning("eplustbl.csv not found - zone areas will use calculated values")
        return result
        
    try:
        logger.info(f"CSV PARSE DEBUG: Opening CSV file: {resolved_path}")
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            reader = csv.reader(csvfile)
            logger.info(f"CSV PARSE DEBUG: Calling _parse_zone_summary_table")
            result = _parse_zone_summary_table(reader)
            logger.info(f"CSV PARSE DEBUG: _parse_zone_summary_table returned {len(result)} zones")
        
        logger.info(f"Read zone areas for {len(result)} zones from eplustbl.csv")
        if result:
            sample_zones = list(result.keys())[:3]
            logger.info(f"CSV PARSE DEBUG: Sample zones from parsing: {sample_zones}")
        return result
        
    except Exception as e:
        logger.warning(f"Error reading zone areas from CSV: {e}")
        import traceback
        logger.error(f"CSV PARSE DEBUG: Full traceback: {traceback.format_exc()}")
        return result

def read_glazing_data_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read glazing data from the eplustbl.csv file.
    Returns a dictionary mapping construction names to their properties.
    Raises FileNotFoundError or ValueError for missing files or headers.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        raise FileNotFoundError("eplustbl.csv not found in provided path or simulation_output directory.")
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            reader = csv.reader(csvfile)
            result = _parse_exterior_fenestration_table(reader)
    except FileNotFoundError:
        raise FileNotFoundError(f"CSV file not found: {resolved_path}")
    except ValueError as e:
        raise ValueError(f"CSV header error: {e}")
    except Exception as e:
        raise RuntimeError(f"Error reading or parsing CSV: {e}")
    return result
