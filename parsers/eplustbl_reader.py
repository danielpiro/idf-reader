"""
Utility to read EnergyPlus eplustbl.csv output files for specific data.

This module provides functions to read key data from the eplustbl.csv output file 
generated by EnergyPlus simulations. Currently it extracts:

1. Glazing area data from "Area of Multiplied Openings [m2]" column
2. Glazing U-value data from "Glass U-Factor [W/m2-K]" column

These values are used in area reports to provide more accurate glazing information
based on the simulation results rather than the IDF input file values.
"""
import csv
import os
from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

def safe_float(value: Any, default: float = 0.0) -> float:
    """
    Safely convert a value to float, returning default if conversion fails.
    """
    if value is None:
        return default
    try:
        return float(value)
    except (ValueError, TypeError):
        return default

def _find_csv_path(csv_path: Optional[str]) -> Optional[str]:
    if csv_path and os.path.exists(csv_path):
        return csv_path
    default_path = os.path.join("simulation_output", "eplustbl.csv")
    if os.path.exists(default_path):
        return default_path
    return None

def _parse_exterior_fenestration_table(reader) -> Dict[str, Dict[str, Any]]:
    header_map = {
        "construction": 1,
        "area of multiplied openings [m2]": 6,
        "glass u-factor [w/m2-k]": 7,
        "glass shgc": 8,
        "glass visible transmittance": 9
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
        if not in_target_table and row[0].strip().lower() == "exterior fenestration":
            in_target_table = True
            headers_found = False
            col_indices = {}
            logger.debug("Found 'Exterior Fenestration' table.")
            continue
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                logger.debug(f"Attempting to find headers in row: {row}")
                if "construction" in current_headers_norm and "glass u-factor [w/m2-k]" in current_headers_norm:
                    for key_map, expected_idx in header_map.items():
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.error(f"Header '{key_map}' not found in {current_headers_norm}. Expected based on map: {header_map}")
                            if key_map not in current_headers_norm:
                                logger.warning(f"Critical header '{key_map}' not found in CSV row: {row}. CSV structure might be unexpected.")

                    missing_keys = [k for k in header_map if k not in col_indices]
                    if missing_keys:
                        logger.error(f"Missing critical column indices for: {missing_keys} after parsing headers {current_headers_norm}")

                    headers_found = True
                    logger.debug(f"Headers identified. Column indices: {col_indices}")
                continue
            else:
                suffixes_to_check = ["_WALL", "_ROOF", "_FLOOR", "_WIN", "_DOOR"]

                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    logger.debug(f"Exiting table parse due to total/blank row: {row}")
                    break

                max_col_idx_needed = 0
                if col_indices:
                    max_col_idx_needed = max(
                        col_indices.get("construction", 0),
                        col_indices.get("area of multiplied openings [m2]", 0),
                        col_indices.get("glass u-factor [w/m2-k]", 0)
                    )

                if len(row) > 1 and row[1].strip() and len(row) > max_col_idx_needed:
                    fenestration_surface_name = row[1].strip()

                    required_cols_for_data = ["construction", "area of multiplied openings [m2]", "glass u-factor [w/m2-k]"]
                    if not all(col_name in col_indices for col_name in required_cols_for_data):
                        logger.warning(f"Skipping row due to missing critical column indices for data extraction: {row}. Found indices: {col_indices}")
                        continue

                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["area of multiplied openings [m2]"]])
                    u_value = safe_float(row[col_indices["glass u-factor [w/m2-k]"]])

                    derived_zone_name = fenestration_surface_name
                    found_suffix = False
                    for suffix in suffixes_to_check:
                        if suffix in fenestration_surface_name:
                            derived_zone_name = fenestration_surface_name.split(suffix)[0]
                            found_suffix = True
                            break
                    if not found_suffix and '_' in fenestration_surface_name:
                        parts = fenestration_surface_name.split('_', 1)
                        if ':' in parts[0]:
                            derived_zone_name = parts[0]

                    logger.debug(
                        f"Processing row: FenSurfName='{fenestration_surface_name}', "
                        f"Constr='{construction_name}', Area='{area}', U-Val='{u_value}', "
                        f"DerivedZone='{derived_zone_name}'"
                    )

                    if fenestration_surface_name and construction_name:
                        result[fenestration_surface_name.upper()] = {
                            'Construction': construction_name,
                            'Area': area,
                            'U-Value': u_value,
                            'DerivedZone': derived_zone_name
                        }
    logger.debug(f"Finished parsing 'Exterior Fenestration' table. Result (keys are uppercased): {result}")
    return result

def read_glazing_data_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read glazing data from the eplustbl.csv file.
    Returns a dictionary mapping construction names to their properties.
    Raises FileNotFoundError or ValueError for missing files or headers.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        raise FileNotFoundError("eplustbl.csv not found in provided path or simulation_output directory.")
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            reader = csv.reader(csvfile)
            result = _parse_exterior_fenestration_table(reader)
    except FileNotFoundError:
        raise FileNotFoundError(f"CSV file not found: {resolved_path}")
    except ValueError as e:
        raise ValueError(f"CSV header error: {e}")
    except Exception as e:
        raise RuntimeError(f"Error reading or parsing CSV: {e}")
    return result
