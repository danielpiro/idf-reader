"""
Utility to read EnergyPlus eplustbl.csv output files for specific data.

This module provides functions to read key data from the eplustbl.csv output file 
generated by EnergyPlus simulations. Currently it extracts:

1. Glazing area data from "Area of Multiplied Openings [m2]" column
2. Glazing U-value data from "Glass U-Factor [W/m2-K]" column

These values are used in area reports to provide more accurate glazing information
based on the simulation results rather than the IDF input file values.
"""
import csv
import os
from typing import Dict, Any, Optional
from utils.logging_config import get_logger

logger = get_logger(__name__)

from .utils import safe_float

def _find_csv_path(csv_path: Optional[str]) -> Optional[str]:
    # Check provided path first
    if csv_path and os.path.exists(csv_path):
        return csv_path
    
    # Try multiple possible locations
    search_paths = [
        os.path.join("simulation_output", "eplustbl.csv"),  # Default relative path
        os.path.join(os.getcwd(), "simulation_output", "eplustbl.csv"),  # Absolute from current directory
        "eplustbl.csv",  # Current directory
        os.path.join("tests", "eplustbl-test.csv")  # Development fallback
    ]
    
    for path in search_paths:
        if os.path.exists(path):
            logger.info(f"Found eplustbl.csv at: {path}")
            return path
    
    logger.warning(f"No eplustbl.csv found. Searched paths: {search_paths}")
    return None


def _parse_exterior_fenestration_table(reader) -> Dict[str, Dict[str, Any]]:
    header_map = {
        "construction": 1,
        "area of multiplied openings [m2]": 6,
        "glass u-factor [w/m2-k]": 7,
        "glass shgc": 8,
        "glass visible transmittance": 9,
        "cardinal direction": 16
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
        if not in_target_table and row[0].strip().lower() == "exterior fenestration":
            in_target_table = True
            headers_found = False
            col_indices = {}
            continue
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                if "construction" in current_headers_norm and "glass u-factor [w/m2-k]" in current_headers_norm:
                    for key_map, expected_idx in header_map.items():
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.error(f"Header '{key_map}' not found in {current_headers_norm}. Expected based on map: {header_map}")
                            if key_map not in current_headers_norm:
                                logger.warning(f"Critical header '{key_map}' not found in CSV row: {row}. CSV structure might be unexpected.")

                    missing_keys = [k for k in header_map if k not in col_indices]
                    if missing_keys:
                        logger.error(f"Missing critical column indices for: {missing_keys} after parsing headers {current_headers_norm}")

                    headers_found = True
                continue
            else:
                suffixes_to_check = ["_WALL", "_ROOF", "_FLOOR", "_WIN", "_DOOR"]

                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    break

                max_col_idx_needed = 0
                if col_indices:
                    max_col_idx_needed = max(
                        col_indices.get("construction", 0),
                        col_indices.get("area of multiplied openings [m2]", 0),
                        col_indices.get("glass u-factor [w/m2-k]", 0)
                    )

                if len(row) > 1 and row[1].strip() and len(row) > max_col_idx_needed:
                    fenestration_surface_name = row[1].strip()

                    required_cols_for_data = ["construction", "area of multiplied openings [m2]", "glass u-factor [w/m2-k]"]
                    if not all(col_name in col_indices for col_name in required_cols_for_data):
                        logger.warning(f"Skipping row due to missing critical column indices for data extraction: {row}. Found indices: {col_indices}")
                        continue

                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["area of multiplied openings [m2]"]])
                    u_value = safe_float(row[col_indices["glass u-factor [w/m2-k]"]])

                    derived_zone_name = fenestration_surface_name
                    found_suffix = False
                    for suffix in suffixes_to_check:
                        if suffix in fenestration_surface_name:
                            derived_zone_name = fenestration_surface_name.split(suffix)[0]
                            found_suffix = True
                            break
                    if not found_suffix and '_' in fenestration_surface_name:
                        parts = fenestration_surface_name.split('_', 1)
                        if ':' in parts[0]:
                            derived_zone_name = parts[0]

                    if fenestration_surface_name and construction_name:
                        result[fenestration_surface_name.upper()] = {
                            'Construction': construction_name,
                            'Area': area,
                            'U-Value': u_value,
                            'DerivedZone': derived_zone_name,
                            'CardinalDirection': row[col_indices["cardinal direction"]].strip() if "cardinal direction" in col_indices else "Unknown"
                        }
    return result

def _parse_opaque_construction_table(reader, table_name: str) -> Dict[str, Dict[str, Any]]:
    """Parse opaque construction tables (Opaque Exterior or Opaque Interior)"""
    header_map = {
        "construction": 2,  # Construction is in column 2, not 1
        "gross area [m2]": 6,  # Gross Area is in column 6 based on CSV structure
        "u-factor with film [w/m2-k]": 4,
        "u-factor no film [w/m2-k]": 5
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
            
        # Look for the target table (e.g., "Opaque Exterior" or "Opaque Interior")
        if not in_target_table and row[0].strip().lower() == table_name.lower():
            in_target_table = True
            headers_found = False
            col_indices = {}
            continue
            
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                if "construction" in current_headers_norm and "gross area [m2]" in current_headers_norm:
                    for key_map in header_map:
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.warning(f"Header '{key_map}' not found in {table_name} table headers")
                    headers_found = True
                continue
            else:
                # Check for end of table
                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    break
                    
                # Extract construction data
                if len(row) > 2 and row[1].strip() and "construction" in col_indices and "gross area [m2]" in col_indices:
                    surface_name = row[1].strip()  # Surface name is always in column 1
                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["gross area [m2]"]])
                    u_factor = safe_float(row[col_indices.get("u-factor with film [w/m2-k]", col_indices.get("u-factor no film [w/m2-k]", 0))])
                    
                    # Store both surface name and construction name as keys
                    surface_data = {
                        'Construction': construction_name,
                        'Area': area,
                        'U-Factor': u_factor,
                        'Type': table_name,
                        'SurfaceName': surface_name
                    }
                    
                    if surface_name:
                        result[surface_name.upper()] = surface_data
                    if construction_name:
                        result[construction_name.upper()] = surface_data
    return result

def read_construction_areas_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read both glazing and opaque construction area data from eplustbl.csv.
    Returns a dictionary mapping surface/construction names to their areas and properties.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        logger.warning("eplustbl.csv not found - construction areas will use calculated values")
        return result
        
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            # Read glazing data from Exterior Fenestration
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            glazing_data = _parse_exterior_fenestration_table(reader)
            result.update(glazing_data)
            
            # Read opaque exterior construction data
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            opaque_exterior = _parse_opaque_construction_table(reader, "Opaque Exterior")
            result.update(opaque_exterior)
            
            # Read opaque interior construction data
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            opaque_interior = _parse_opaque_construction_table(reader, "Opaque Interior")
            result.update(opaque_interior)
            
        logger.info(f"Read construction areas for {len(result)} items from eplustbl.csv")
        return result
        
    except Exception as e:
        logger.warning(f"Error reading construction areas from CSV: {e}")
        return result

def _parse_zone_summary_table(reader) -> Dict[str, Dict[str, Any]]:
    """Parse the Zone Summary table to extract zone areas."""
    result = {}
    in_zone_summary = False
    headers_found = False
    col_indices = {}
    
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
            
        # Look for Zone Summary table
        if not in_zone_summary and row[0].strip() == "Zone Summary":
            in_zone_summary = True
            headers_found = False
            col_indices = {}
            continue
            
        if in_zone_summary:
            if not headers_found:
                # Look for the headers row
                current_headers_norm = [h.strip().lower() for h in row]
                if "area [m2]" in current_headers_norm:
                    try:
                        col_indices["area"] = current_headers_norm.index("area [m2]")
                        col_indices["volume"] = current_headers_norm.index("volume [m3]") if "volume [m3]" in current_headers_norm else None
                        col_indices["multipliers"] = current_headers_norm.index("multipliers") if "multipliers" in current_headers_norm else None
                        headers_found = True
                        logger.debug(f"Found Zone Summary headers: {col_indices}")
                    except ValueError as e:
                        logger.warning(f"Error parsing Zone Summary headers: {e}")
                continue
            else:
                # Process data rows
                if len(row) > 1 and row[1].strip():  # Zone name is in column 1
                    zone_name = row[1].strip()
                    
                    # Skip if this is another table (like "Zone Information")
                    if zone_name.lower() in ["zone information", "number of zones"]:
                        break
                        
                    if "area" in col_indices and len(row) > col_indices["area"]:
                        try:
                            area = safe_float(row[col_indices["area"]])
                            multiplier = 1.0
                            if col_indices["multipliers"] and len(row) > col_indices["multipliers"]:
                                multiplier = safe_float(row[col_indices["multipliers"]], 1.0)
                            
                            volume = None
                            if col_indices["volume"] and len(row) > col_indices["volume"]:
                                volume = safe_float(row[col_indices["volume"]])
                            
                            result[zone_name] = {
                                'Area': area,
                                'Volume': volume,
                                'Multiplier': multiplier
                            }
                            logger.debug(f"Parsed zone {zone_name}: area={area}, multiplier={multiplier}")
                        except (ValueError, IndexError) as e:
                            logger.warning(f"Error parsing zone data for {zone_name}: {e}")
                            continue
    
    return result

def _parse_zone_summary_table(reader) -> Dict[str, Dict[str, Any]]:
    """
    Parse the Zone Summary table from EnergyPlus CSV output.
    
    Returns:
        Dict mapping zone names to {'area': float, 'multiplier': int}
    """
    result = {}
    in_zone_summary = False
    headers = []
    row_count = 0
    
    for row in reader:
        row_count += 1
        if not row:
            continue
            
        # Debug: Log first 10 rows to see CSV structure
        if row_count <= 10:
            logger.debug(f"CSV row {row_count}: {row}")
            
        # Look for Zone Summary table header
        if len(row) > 0 and 'Zone Summary' in str(row[0]):
            logger.debug(f"Found Zone Summary table at row {row_count}")
            in_zone_summary = True
            continue
        
        if in_zone_summary:
            # Check if this is the header row (contains "Area [m2]" and "Multipliers")
            if not headers and row and any('Area [m2]' in str(cell) for cell in row):
                headers = [str(cell).strip().lower() for cell in row]
                logger.debug(f"Found Zone Summary headers: {headers}")
                continue
            
            # Check if we've reached the end of the table (empty row or new section)
            if headers and row and (not row[0] or row[0].strip() == '' or ('End' in str(row[0]) and 'Zone' in str(row[0]))):
                logger.debug(f"End of Zone Information table at row {row_count}")
                break
                
            # Process data rows
            if headers and row and len(row) >= len(headers):
                try:
                    # Zone name is always in column 1 (index 1)
                    zone_name_idx = 1
                    area_idx = None
                    multiplier_idx = None
                    
                    # Find area and multiplier columns
                    for i, header in enumerate(headers):
                        header_lower = str(header).strip().lower()
                        if 'area [m2]' in header_lower:
                            area_idx = i
                            logger.debug(f"Found Area column at index {i}")
                        elif 'multiplier' in header_lower:
                            multiplier_idx = i  
                            logger.debug(f"Found Multiplier column at index {i}")
                    
                    if zone_name_idx is not None and area_idx is not None:
                        zone_name = str(row[zone_name_idx]).strip()
                        area = safe_float(row[area_idx], 0.0)
                        multiplier = int(safe_float(row[multiplier_idx], 1.0)) if multiplier_idx is not None else 1
                        
                        if zone_name and area > 0:
                            result[zone_name] = {
                                'area': area,
                                'multiplier': multiplier
                            }
                            logger.debug(f"Parsed zone {zone_name}: area={area}, multiplier={multiplier}")
                        
                except (ValueError, IndexError) as e:
                    logger.warning(f"Error parsing zone data: {e}")
                    continue
    
    if not in_zone_summary:
        logger.warning("Zone Summary table not found in CSV")
    elif not headers:
        logger.warning("Zone Summary headers not found")
    else:
        logger.debug(f"Processed Zone Summary table, found {len(result)} zones")
    
    return result

def read_zone_areas_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read zone area data from the eplustbl.csv file Zone Summary table.
    Returns a dictionary mapping zone names to their area data.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        logger.warning("eplustbl.csv not found - zone areas will use calculated values")
        return result
        
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            reader = csv.reader(csvfile)
            result = _parse_zone_summary_table(reader)
        
        logger.info(f"Read zone areas for {len(result)} zones from eplustbl.csv")
        return result
        
    except Exception as e:
        logger.warning(f"Error reading zone areas from CSV: {e}")
        return result

def read_glazing_data_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read glazing data from the eplustbl.csv file.
    Returns a dictionary mapping construction names to their properties.
    Raises FileNotFoundError or ValueError for missing files or headers.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        raise FileNotFoundError("eplustbl.csv not found in provided path or simulation_output directory.")
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            reader = csv.reader(csvfile)
            result = _parse_exterior_fenestration_table(reader)
    except FileNotFoundError:
        raise FileNotFoundError(f"CSV file not found: {resolved_path}")
    except ValueError as e:
        raise ValueError(f"CSV header error: {e}")
    except Exception as e:
        raise RuntimeError(f"Error reading or parsing CSV: {e}")
    return result
