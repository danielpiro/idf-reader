"""
Utility to read EnergyPlus eplustbl.csv output files for specific data.

This module provides functions to read key data from the eplustbl.csv output file 
generated by EnergyPlus simulations. Currently it extracts:

1. Glazing area data from "Area of Multiplied Openings [m2]" column
2. Glazing U-value data from "Glass U-Factor [W/m2-K]" column

These values are used in area reports to provide more accurate glazing information
based on the simulation results rather than the IDF input file values.
"""
import csv
import os
from typing import Dict, Any, Optional
from utils.logging_config import get_logger

logger = get_logger(__name__)

from .utils import safe_float

def _find_csv_path(csv_path: Optional[str]) -> Optional[str]:
    # Check provided path first
    if csv_path and os.path.exists(csv_path):
        return csv_path
    
    # Try multiple possible locations
    search_paths = [
        os.path.join("simulation_output", "eplustbl.csv"),  # Default relative path
        os.path.join(os.getcwd(), "simulation_output", "eplustbl.csv"),  # Absolute from current directory
        "eplustbl.csv",  # Current directory
        os.path.join("tests", "eplustbl-test.csv")  # Development fallback
    ]
    
    for path in search_paths:
        if os.path.exists(path):
            logger.info(f"Found eplustbl.csv at: {path}")
            return path
    
    logger.warning(f"No eplustbl.csv found. Searched paths: {search_paths}")
    return None

def _parse_exterior_fenestration_table(reader) -> Dict[str, Dict[str, Any]]:
    header_map = {
        "construction": 1,
        "area of multiplied openings [m2]": 6,
        "glass u-factor [w/m2-k]": 7,
        "glass shgc": 8,
        "glass visible transmittance": 9,
        "cardinal direction": 16
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
        if not in_target_table and row[0].strip().lower() == "exterior fenestration":
            in_target_table = True
            headers_found = False
            col_indices = {}
            continue
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                if "construction" in current_headers_norm and "glass u-factor [w/m2-k]" in current_headers_norm:
                    for key_map, expected_idx in header_map.items():
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.error(f"Header '{key_map}' not found in {current_headers_norm}. Expected based on map: {header_map}")
                            if key_map not in current_headers_norm:
                                logger.warning(f"Critical header '{key_map}' not found in CSV row: {row}. CSV structure might be unexpected.")

                    missing_keys = [k for k in header_map if k not in col_indices]
                    if missing_keys:
                        logger.error(f"Missing critical column indices for: {missing_keys} after parsing headers {current_headers_norm}")

                    headers_found = True
                continue
            else:
                suffixes_to_check = ["_WALL", "_ROOF", "_FLOOR", "_WIN", "_DOOR"]

                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    break

                max_col_idx_needed = 0
                if col_indices:
                    max_col_idx_needed = max(
                        col_indices.get("construction", 0),
                        col_indices.get("area of multiplied openings [m2]", 0),
                        col_indices.get("glass u-factor [w/m2-k]", 0)
                    )

                if len(row) > 1 and row[1].strip() and len(row) > max_col_idx_needed:
                    fenestration_surface_name = row[1].strip()

                    required_cols_for_data = ["construction", "area of multiplied openings [m2]", "glass u-factor [w/m2-k]"]
                    if not all(col_name in col_indices for col_name in required_cols_for_data):
                        logger.warning(f"Skipping row due to missing critical column indices for data extraction: {row}. Found indices: {col_indices}")
                        continue

                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["area of multiplied openings [m2]"]])
                    u_value = safe_float(row[col_indices["glass u-factor [w/m2-k]"]])

                    derived_zone_name = fenestration_surface_name
                    found_suffix = False
                    for suffix in suffixes_to_check:
                        if suffix in fenestration_surface_name:
                            derived_zone_name = fenestration_surface_name.split(suffix)[0]
                            found_suffix = True
                            break
                    if not found_suffix and '_' in fenestration_surface_name:
                        parts = fenestration_surface_name.split('_', 1)
                        if ':' in parts[0]:
                            derived_zone_name = parts[0]

                    if fenestration_surface_name and construction_name:
                        result[fenestration_surface_name.upper()] = {
                            'Construction': construction_name,
                            'Area': area,
                            'U-Value': u_value,
                            'DerivedZone': derived_zone_name,
                            'CardinalDirection': row[col_indices["cardinal direction"]].strip() if "cardinal direction" in col_indices else "Unknown"
                        }
    return result

def _parse_opaque_construction_table(reader, table_name: str) -> Dict[str, Dict[str, Any]]:
    """Parse opaque construction tables (Opaque Exterior or Opaque Interior)"""
    header_map = {
        "construction": 2,  # Construction is in column 2, not 1
        "gross area [m2]": 6,  # Gross Area is in column 6 based on CSV structure
        "u-factor with film [w/m2-k]": 4,
        "u-factor no film [w/m2-k]": 5
    }
    col_indices = {}
    result = {}
    in_target_table = False
    headers_found = False
    
    for row in reader:
        if not row or not any(field.strip() for field in row):
            continue
            
        # Look for the target table (e.g., "Opaque Exterior" or "Opaque Interior")
        if not in_target_table and row[0].strip().lower() == table_name.lower():
            in_target_table = True
            headers_found = False
            col_indices = {}
            continue
            
        if in_target_table:
            if not headers_found:
                current_headers_norm = [h.strip().lower() for h in row]
                if "construction" in current_headers_norm and "gross area [m2]" in current_headers_norm:
                    for key_map in header_map:
                        try:
                            col_indices[key_map] = current_headers_norm.index(key_map)
                        except ValueError:
                            logger.warning(f"Header '{key_map}' not found in {table_name} table headers")
                    headers_found = True
                continue
            else:
                # Check for end of table
                is_total_row = row[0].strip().lower().endswith("total or average")
                is_blank_data_row = not row[0].strip() and (len(row) < 2 or not row[1].strip())
                if is_total_row or is_blank_data_row:
                    break
                    
                # Extract construction data
                if len(row) > 2 and row[1].strip() and "construction" in col_indices and "gross area [m2]" in col_indices:
                    surface_name = row[1].strip()  # Surface name is always in column 1
                    construction_name = row[col_indices["construction"]].strip()
                    area = safe_float(row[col_indices["gross area [m2]"]])
                    u_factor = safe_float(row[col_indices.get("u-factor with film [w/m2-k]", col_indices.get("u-factor no film [w/m2-k]", 0))])
                    
                    # Store both surface name and construction name as keys
                    surface_data = {
                        'Construction': construction_name,
                        'Area': area,
                        'U-Factor': u_factor,
                        'Type': table_name,
                        'SurfaceName': surface_name
                    }
                    
                    if surface_name:
                        result[surface_name.upper()] = surface_data
                    if construction_name:
                        result[construction_name.upper()] = surface_data
    return result

def read_construction_areas_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read both glazing and opaque construction area data from eplustbl.csv.
    Returns a dictionary mapping surface/construction names to their areas and properties.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        logger.warning("eplustbl.csv not found - construction areas will use calculated values")
        return result
        
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            # Read glazing data from Exterior Fenestration
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            glazing_data = _parse_exterior_fenestration_table(reader)
            result.update(glazing_data)
            
            # Read opaque exterior construction data
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            opaque_exterior = _parse_opaque_construction_table(reader, "Opaque Exterior")
            result.update(opaque_exterior)
            
            # Read opaque interior construction data
            csvfile.seek(0)
            reader = csv.reader(csvfile)
            opaque_interior = _parse_opaque_construction_table(reader, "Opaque Interior")
            result.update(opaque_interior)
            
        logger.info(f"Read construction areas for {len(result)} items from eplustbl.csv")
        return result
        
    except Exception as e:
        logger.warning(f"Error reading construction areas from CSV: {e}")
        return result

def read_glazing_data_from_csv(csv_path: Optional[str] = None) -> Dict[str, Dict[str, Any]]:
    """
    Read glazing data from the eplustbl.csv file.
    Returns a dictionary mapping construction names to their properties.
    Raises FileNotFoundError or ValueError for missing files or headers.
    """
    result = {}
    resolved_path = _find_csv_path(csv_path)
    if not resolved_path:
        raise FileNotFoundError("eplustbl.csv not found in provided path or simulation_output directory.")
    try:
        with open(resolved_path, 'r', encoding='utf-8', errors='ignore') as csvfile:
            reader = csv.reader(csvfile)
            result = _parse_exterior_fenestration_table(reader)
    except FileNotFoundError:
        raise FileNotFoundError(f"CSV file not found: {resolved_path}")
    except ValueError as e:
        raise ValueError(f"CSV header error: {e}")
    except Exception as e:
        raise RuntimeError(f"Error reading or parsing CSV: {e}")
    return result
